# SPDX-FileCopyrightText: 2022 Martin Byrenheid <martin@byrenheid.net>
#
# SPDX-License-Identifier: GPL-3.0-or-later

from typing import List, Union, Dict, cast
import datetime
import dateutil.tz as tz
import icalendar

from icalwarrior.input.date import adapt_datetype
from icalwarrior.configuration import Configuration
import icalwarrior.constants as constants

class UnknownPropertyError(Exception):
    def __init__(self, prop : str, supported : List[str]) -> None:
        self.prop = prop
        self.supported = supported

    def __str__(self) -> str:
        return "Unknown property \"" + self.prop + "\". Supported properties are " + ", ".join(self.supported)

class InvalidContextError(Exception):
    def __init__(self, context : str, supported : List[str]) -> None:
        self.context = context
        self.supported = supported

    def __str__(self) -> str:
        return "Invalid context key \"" + self.context + "\". Supported keys are " + ", ".join(self.supported)

class TodoModel:

    DATE_PROPERTIES = [
        'due',
        'dtstart',
        'dtend',
        'completed'
    ]

    TEXT_PROPERTIES = [
        'summary',
        'description',
        'categories',
    ]

    INT_PROPERTIES = [
        'priority',
        'percent-complete'
    ]

    CONTEXT_PROPERTIES = [
        'id',
        'list'
    ]

    ENUM_PROPERTIES = [
        'status'
    ]

    ENUM_VALUES = {
        'status' : ["needs-action", "completed", "in-process", "cancelled"]
    }

    DATE_IMMUTABLE_PROPERTIES = [
        'created'
    ]

    TEXT_IMMUTABLE_PROPERTIES = [
        'uid'
    ]

    DEFAULT_PROPERTY_VALUES = {
        'status' : 'needs-action'
    }

    @staticmethod
    def __set_default_values(todo : icalendar.Todo) -> None:
        for prop_name, prop_val in TodoModel.DEFAULT_PROPERTY_VALUES.items():

            if prop_name not in todo:
                factory = icalendar.prop.TypesFactory().for_property(prop_name)
                parsed_val = factory(factory.from_ical(prop_val))
                todo.add(prop_name, parsed_val, encode=False)

    @staticmethod
    def supported_properties() -> List[str]:
        return TodoModel.DATE_PROPERTIES + TodoModel.TEXT_PROPERTIES + TodoModel.ENUM_PROPERTIES + TodoModel.INT_PROPERTIES

    def __init__(self, configuration : Configuration, todo : icalendar.Todo):
        self.todo = todo

        # Add default values for properties that are missing, so that we do not
        # need to handle absent values during filtering etc.
        self.__set_default_values(self.todo)

        self.context : Dict[str, Union[str, int]] = {}

    def get_property_names(self) -> List[str]:
        result = [k for k in list(self.todo.keys()) if k.lower() != "context"]
        return result

    def set_properties(self, property_dict : Dict[str, Union[str, int, datetime.datetime, datetime.date, List[str]]]) -> None:
        # Collect categories in list and add it once to the todo
        # as otherwise, icalendar will add a separate CATEGORIES-line
        # for each category.
        modified = False

        categories = []
        # Make sure we consider existing categories
        if self.has_property('categories'):
            existing_categories = self.get_categories()
            categories = [str(c) for c in existing_categories]

        # Check if the user specified category modifiers
        if 'category_modifiers' in property_dict:

            # Casting to list[str] should be fine here, given that the list of category
            # modifiers is generated by calling input.cli.decode_property_list.
            for modifier in cast(list[str], property_dict['category_modifiers']):

                modifier_type = modifier[0]
                category_name = modifier[1:]

                if modifier_type == constants.CATEGORY_INCLUDE_PREFIX and category_name not in categories:
                    categories.append(category_name)
                else:
                    categories.remove(category_name)

            del property_dict['category_modifiers']

        # Check if the user specified categories explicitly
        elif 'categories' in property_dict:

            # Casting to list[str] should be fine here, given that the list of categories
            # is generated by calling input.cli.decode_property_list.
            categories = cast(list[str], property_dict['categories'])

            # Prevent erroneous adding of categories
            # in the following loop
            del property_dict['categories']

        for prop_name, prop_value in property_dict.items():

            if prop_name.upper() in icalendar.Todo.singletons and prop_name in self.todo:

                del self.todo[prop_name]

            # If the value is an empty string,
            # we just delete it.
            if prop_value != "":
                self.todo.add(prop_name, prop_value, encode=True)

            modified = True

        if 'categories' in self.todo:
            del self.todo['categories']

        if len(categories) > 0:
            self.todo.add("categories", categories)
            modified = True

        if modified:
            self.__update_modification_timestamps()

    def __update_modification_timestamps(self) -> None:
        if 'last-modified' in self.todo:
            del self.todo['last-modified']
        self.todo.add('last-modified', datetime.datetime.now(tz.gettz()))

        del self.todo['dtstamp']
        self.todo.add('dtstamp', datetime.datetime.now(tz.gettz()))

    def get_ical_todo(self) -> icalendar.Todo:
        return self.todo

    def get_context(self, key : str) -> Union[str, int]:
        return self.context[key]

    def set_context(self, key : str, value : Union[str, int]) -> None:

        if key not in TodoModel.CONTEXT_PROPERTIES:
            raise InvalidContextError(key, TodoModel.CONTEXT_PROPERTIES)

        self.context[key] = value

    def get_datetime(self, prop_name : str) -> datetime.datetime:

        result = icalendar.prop.vDDDTypes.from_ical(self.todo[prop_name])
        if isinstance(result, (datetime.datetime, datetime.date)):
            result = adapt_datetype(result, icalendar.prop.vDDDTypes(datetime.datetime.now()))
            # Additional check for datetime.datetime instance to make mypy happy
            if isinstance(result, datetime.datetime):
                return result

        raise Exception("Object of non-datetime type " + type(result).__name__ + " given.")

    def get_date_or_datetime(self, prop_name : str) -> datetime.datetime | datetime.date:

        result = icalendar.prop.vDDDTypes.from_ical(self.todo[prop_name])
        if isinstance(result, (datetime.datetime, datetime.date)):
            return result

        raise Exception("Object of non-datetime  or date type " + type(result).__name__ + " given.")

    def get_categories(self) -> List[str]:

        categories = self.todo['categories']
        if isinstance(categories, icalendar.prop.vCategory):
            result = categories.cats
            if isinstance(result, list) and (len(result) == 0 or isinstance(result[0], str)):
                return result

        raise Exception("Object of non-list type " + type(result).__name__ + " given.")

    def get_int(self, prop_name : str) -> int:

        result = icalendar.prop.vInt.from_ical(self.todo[prop_name])
        if isinstance(result, int):
            return result

        raise Exception("Object of non-int type " + type(result).__name__ + " given.")

    def get_string(self, prop_name : str) -> str:

        result = icalendar.prop.vText.from_ical(self.todo[prop_name])
        if isinstance(result, str):
            return result

        raise Exception("Object of non-string type " + type(result).__name__ + " given.")

    def has_property(self, prop_name : str) -> bool:
        return prop_name in self.todo

    def unset_property(self, prop_name : str) -> None:
        del self.todo[prop_name]
